#!/usr/bin/env node

const { Command } = require('commander');
const inquirer = require('inquirer');
const chalk = require('chalk');
const ora = require('ora');
const fs = require('fs-extra');
const path = require('path');
const { Octokit } = require('@octokit/rest');
const simpleGit = require('simple-git');
const Conf = require('conf');
const open = require('open');

const program = new Command();

// Configuration setup
const config = new Conf({
  projectName: 'platform-toolkit',
  defaults: {
    github: {
      token: null,
      username: null,
      email: null,
      defaultVisibility: 'public',
      defaultOrg: null
    },
    preferences: {
      autoGitInit: true,
      autoNpmInstall: false
    }
  }
});

// Template metadata
const templates = {
  api: {
    name: 'Node.js API',
    description: 'Production-ready REST API with TypeScript',
    techStack: ['TypeScript 5.x', 'Express.js 4.x', 'PostgreSQL 15 + TypeORM', 'Redis 7', 'Docker + Docker Compose'],
    features: [
      'RESTful endpoints (Users, Tasks)',
      'Database migrations',
      'Redis caching',
      'Health checks',
      'Security (Helmet, CORS)',
      'Production Dockerfile'
    ],
    path: 'node-api-template',
    emoji: 'ðŸ“¦'
  },
  microservices: {
    name: 'CloudBill Microservices',
    description: 'Multi-tenant SaaS platform architecture',
    techStack: ['TypeScript', '5 Services', 'API Gateway', 'Kubernetes', 'Prometheus', 'Grafana'],
    features: [
      '5 microservices (Auth, Billing, Invoicing, Notifications, Analytics)',
      'Multi-tenant architecture',
      'Kubernetes manifests (Kustomize)',
      '213 tests with 90%+ coverage',
      'Observability (Prometheus, Grafana)',
      'Production-ready Docker Compose'
    ],
    path: 'microservices-template',
    emoji: 'ðŸš€'
  }
};

// ============================================================================
// Validation Helpers
// ============================================================================

function validateServiceName(name) {
  if (!name || name.trim().length === 0) {
    return 'Service name is required';
  }

  if (name.length < 3) {
    return 'Service name must be at least 3 characters';
  }

  if (!/^[a-z0-9-]+$/.test(name)) {
    return 'Service name must contain only lowercase letters, numbers, and hyphens';
  }

  const targetPath = path.join(process.cwd(), name);
  if (fs.existsSync(targetPath)) {
    return `Directory "${name}" already exists`;
  }

  return true;
}

// ============================================================================
// GitHub Helper Functions
// ============================================================================

function getOctokit() {
  const token = config.get('github.token');
  if (!token) {
    return null;
  }
  return new Octokit({ auth: token });
}

async function verifyGitHubToken(token) {
  try {
    const octokit = new Octokit({ auth: token });
    const { data } = await octokit.users.getAuthenticated();
    return { success: true, user: data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}

async function createGitHubRepository(serviceName, options = {}) {
  const spinner = ora('Creating GitHub repository...').start();

  try {
    const octokit = getOctokit();
    if (!octokit) {
      spinner.fail(chalk.red('Not authenticated with GitHub'));
      console.log(chalk.yellow('\nRun: platform github login'));
      return null;
    }

    const { data } = await octokit.repos.createForAuthenticatedUser({
      name: serviceName,
      description: options.description || `Generated by platform-toolkit`,
      private: options.visibility === 'private',
      auto_init: false
    });

    spinner.succeed(chalk.green('Repository created on GitHub'));
    return data;
  } catch (error) {
    if (error.status === 422) {
      spinner.fail(chalk.red(`Repository "${serviceName}" already exists on GitHub`));

      const answers = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'useExisting',
          message: 'Use existing repository?',
          default: true
        }
      ]);

      if (answers.useExisting) {
        try {
          const username = config.get('github.username');
          const { data } = await octokit.repos.get({
            owner: username,
            repo: serviceName
          });
          return data;
        } catch (err) {
          console.error(chalk.red(`Error: ${err.message}`));
          return null;
        }
      }
      return null;
    } else if (error.status === 401) {
      spinner.fail(chalk.red('GitHub authentication failed'));
      console.log(chalk.yellow('\nYour token may have expired.'));
      console.log(chalk.cyan('To fix:'));
      console.log('  1. Create new token: https://github.com/settings/tokens');
      console.log('  2. Run: platform github login');
      return null;
    } else {
      spinner.fail(chalk.red('Failed to create repository'));
      console.error(chalk.red(`Error: ${error.message}`));
      return null;
    }
  }
}

async function pushToGitHub(targetPath, repoUrl, serviceName) {
  const spinner = ora('Pushing to GitHub...').start();

  try {
    const git = simpleGit(targetPath);

    // Check if git is initialized
    const isRepo = await git.checkIsRepo();
    if (!isRepo) {
      spinner.text = 'Initializing git repository...';
      await git.init();
      await git.add('.');
      await git.commit(`Initial commit: ${serviceName}`);
    }

    // Add remote
    spinner.text = 'Adding remote origin...';
    try {
      await git.addRemote('origin', repoUrl);
    } catch (error) {
      // Remote might already exist
      if (!error.message.includes('already exists')) {
        throw error;
      }
    }

    // Rename to main branch
    spinner.text = 'Renaming branch to main...';
    try {
      await git.branch(['-M', 'main']);
    } catch (error) {
      // Branch might already be main
    }

    // Push to GitHub
    spinner.text = 'Pushing to GitHub...';
    await git.push(['-u', 'origin', 'main']);

    spinner.succeed(chalk.green('Code pushed to GitHub'));
    return true;
  } catch (error) {
    spinner.fail(chalk.red('Failed to push to GitHub'));
    console.error(chalk.red(`Error: ${error.message}`));
    return false;
  }
}

// ============================================================================
// Git Helper Functions
// ============================================================================

async function initGit(targetPath, serviceName) {
  try {
    const git = simpleGit(targetPath);
    await git.init();
    await git.add('.');
    await git.commit(`Initial commit: ${serviceName}`);
    return true;
  } catch (error) {
    return false;
  }
}

// ============================================================================
// Interactive Create Flow
// ============================================================================

async function interactiveCreate() {
  console.log(chalk.cyan.bold('\nðŸ› ï¸  Platform Engineering Toolkit\n'));

  const questions = [
    {
      type: 'list',
      name: 'type',
      message: 'Select template:',
      choices: [
        {
          name: `${templates.api.emoji} api           - ${templates.api.description}`,
          value: 'api'
        },
        {
          name: `${templates.microservices.emoji} microservices - ${templates.microservices.description}`,
          value: 'microservices'
        }
      ]
    },
    {
      type: 'input',
      name: 'name',
      message: 'Service name:',
      validate: validateServiceName
    }
  ];

  // Check if GitHub is configured
  const hasGitHubToken = config.get('github.token');

  if (hasGitHubToken) {
    questions.push({
      type: 'confirm',
      name: 'createGitHub',
      message: 'Create GitHub repository?',
      default: false
    });
  } else {
    questions.push({
      type: 'confirm',
      name: 'initGit',
      message: 'Initialize git repository?',
      default: true
    });
  }

  const answers = await inquirer.prompt(questions);

  // Additional GitHub questions if creating repository
  if (answers.createGitHub) {
    const githubQuestions = await inquirer.prompt([
      {
        type: 'list',
        name: 'visibility',
        message: 'Repository visibility:',
        choices: [
          { name: 'Public', value: 'public' },
          { name: 'Private', value: 'private' }
        ],
        default: config.get('github.defaultVisibility')
      },
      {
        type: 'input',
        name: 'description',
        message: 'Repository description:',
        default: templates[answers.type].description
      }
    ]);

    return { ...answers, ...githubQuestions };
  }

  return answers;
}

// ============================================================================
// Create Service Function
// ============================================================================

async function createService(type, name, options = {}) {
  const spinner = ora('Creating service...').start();

  try {
    const template = templates[type];
    if (!template) {
      spinner.fail(chalk.red(`Invalid type. Use: ${Object.keys(templates).join(', ')}`));
      process.exit(1);
    }

    const templatePath = path.join(__dirname, '../templates', template.path);
    const targetPath = path.join(process.cwd(), name);

    // Validate target path
    if (fs.existsSync(targetPath)) {
      spinner.fail(chalk.red(`Directory "${name}" already exists!`));
      process.exit(1);
    }

    // Copy template
    spinner.text = 'Copying template files...';
    await fs.copy(templatePath, targetPath);

    spinner.succeed(chalk.green('Service files created'));

    let repoUrl = null;
    let gitInitialized = false;

    // GitHub integration
    if (options.github || options.createGitHub) {
      // Initialize git first
      spinner.start('Initializing git repository...');
      const gitSuccess = await initGit(targetPath, name);
      if (!gitSuccess) {
        spinner.warn(chalk.yellow('Git initialization failed'));
        return;
      }
      spinner.succeed(chalk.green('Git repository initialized'));
      gitInitialized = true;

      // Create GitHub repository
      const repo = await createGitHubRepository(name, {
        description: options.description,
        visibility: options.visibility || 'public'
      });

      if (repo) {
        repoUrl = repo.html_url;

        // Push to GitHub
        const pushSuccess = await pushToGitHub(targetPath, repo.clone_url, name);

        if (!pushSuccess) {
          console.log(chalk.yellow('\nRepository created but push failed.'));
          console.log(chalk.cyan('To push manually:'));
          console.log(chalk.gray(`  cd ${name}`));
          console.log(chalk.gray(`  git remote add origin ${repo.clone_url}`));
          console.log(chalk.gray(`  git push -u origin main`));
        }
      }
    } else if (options.initGit) {
      // Just initialize git without GitHub
      spinner.start('Initializing git repository...');
      const gitSuccess = await initGit(targetPath, name);
      if (gitSuccess) {
        spinner.succeed(chalk.green('Git repository initialized'));
        gitInitialized = true;
      } else {
        spinner.warn(chalk.yellow('Git initialization failed (continuing anyway)'));
      }
    }

    // Success output
    console.log(chalk.green.bold('\nâœ… Success!\n'));

    console.log(chalk.cyan('ðŸ“¦ Local: ') + chalk.gray(targetPath));
    if (repoUrl) {
      console.log(chalk.cyan('ðŸ”— GitHub:') + chalk.gray(` ${repoUrl}`));
    }

    if (gitInitialized || repoUrl) {
      console.log(chalk.cyan('\nGit:'));
      if (gitInitialized) {
        console.log(chalk.gray('  âœ” Repository initialized'));
        console.log(chalk.gray('  âœ” Initial commit created'));
      }
      if (repoUrl) {
        console.log(chalk.gray('  âœ” Pushed to main branch'));
      }
    }

    console.log(chalk.cyan('\nNext steps:'));
    console.log(chalk.gray(`  cd ${name}`));
    console.log(chalk.gray(`  npm install`));
    console.log(chalk.gray(`  npm run dev`));

    if (repoUrl) {
      console.log(chalk.cyan('\nView on GitHub:'));
      console.log(chalk.gray(`  platform github open`));
    }
    console.log();

  } catch (error) {
    spinner.fail(chalk.red('Failed to create service'));
    console.error(chalk.red(`Error: ${error.message}`));
    process.exit(1);
  }
}

// ============================================================================
// CLI Commands
// ============================================================================

program
  .name('platform')
  .description('Platform Engineering Toolkit CLI')
  .version('1.0.0');

// Create command
program
  .command('create [type] [name]')
  .description('Create service from template (api or microservices)')
  .option('-g, --github', 'Create GitHub repository')
  .option('-p, --private', 'Make repository private (requires --github)')
  .option('-d, --description <desc>', 'Repository description')
  .action(async (type, name, cmdOptions) => {
    // Interactive mode if no arguments provided
    if (!type || !name) {
      const answers = await interactiveCreate();
      await createService(answers.type, answers.name, answers);
    } else {
      // Validate service name
      const validation = validateServiceName(name);
      if (validation !== true) {
        console.error(chalk.red(`Error: ${validation}`));
        process.exit(1);
      }

      // Build options
      const options = {
        initGit: true,
        github: cmdOptions.github,
        visibility: cmdOptions.private ? 'private' : 'public',
        description: cmdOptions.description
      };

      await createService(type, name, options);
    }
  });

// List command
program
  .command('list')
  .description('List available templates')
  .action(() => {
    console.log(chalk.cyan.bold('\nAvailable Templates:\n'));

    Object.entries(templates).forEach(([key, template]) => {
      console.log(chalk.green.bold(`${template.emoji} ${key}`));
      console.log(chalk.white(`   ${template.description}`));
      console.log(chalk.gray(`   Features: ${template.features.slice(0, 2).join(', ')}`));
      console.log(chalk.gray(`   Deployment: Docker Compose, Kubernetes ready`));
      console.log();
    });

    console.log(chalk.cyan('Use: platform create <template> <name>'));
    console.log(chalk.cyan('  Or: platform create (interactive)\n'));
  });

// Info command
program
  .command('info <type>')
  .description('Show detailed information about a template')
  .action((type) => {
    const template = templates[type];

    if (!template) {
      console.error(chalk.red(`\nError: Template "${type}" not found.`));
      console.log(chalk.cyan(`Available templates: ${Object.keys(templates).join(', ')}\n`));
      process.exit(1);
    }

    console.log(chalk.cyan.bold(`\n${template.emoji} ${template.name}`));
    console.log(chalk.white(`Description: ${template.description}\n`));

    console.log(chalk.green.bold('Tech Stack:'));
    template.techStack.forEach(tech => {
      console.log(chalk.gray(`  â€¢ ${tech}`));
    });

    console.log(chalk.green.bold('\nFeatures:'));
    template.features.forEach(feature => {
      console.log(chalk.gray(`  â€¢ ${feature}`));
    });

    console.log(chalk.green.bold('\nQuick Start:'));
    console.log(chalk.gray(`  platform create ${type} my-service`));
    console.log(chalk.gray(`  cd my-service`));
    console.log(chalk.gray(`  npm install`));
    console.log(chalk.gray(`  npm run dev\n`));
  });

// ============================================================================
// GitHub Commands
// ============================================================================

const github = program
  .command('github')
  .description('GitHub integration commands');

// GitHub login
github
  .command('login')
  .description('Authenticate with GitHub')
  .action(async () => {
    console.log(chalk.cyan.bold('\nðŸ” GitHub Authentication\n'));
    console.log(chalk.gray('Create a token at: https://github.com/settings/tokens'));
    console.log(chalk.gray('Required scopes: repo (all)\n'));

    const answers = await inquirer.prompt([
      {
        type: 'password',
        name: 'token',
        message: 'Enter GitHub Personal Access Token:',
        mask: '*',
        validate: (input) => {
          if (!input || input.trim().length === 0) {
            return 'Token is required';
          }
          return true;
        }
      }
    ]);

    const spinner = ora('Verifying token...').start();
    const result = await verifyGitHubToken(answers.token);

    if (result.success) {
      config.set('github.token', answers.token);
      config.set('github.username', result.user.login);
      config.set('github.email', result.user.email);

      spinner.succeed(chalk.green(`Successfully authenticated as ${result.user.login}`));
      console.log(chalk.gray(`Token saved to: ${config.path}\n`));
    } else {
      spinner.fail(chalk.red('Authentication failed'));
      console.error(chalk.red(`Error: ${result.error}\n`));
      process.exit(1);
    }
  });

// GitHub logout
github
  .command('logout')
  .description('Remove GitHub authentication')
  .action(() => {
    const username = config.get('github.username');
    config.delete('github.token');
    config.delete('github.username');
    config.delete('github.email');

    console.log(chalk.green(`\nâœ” Logged out${username ? ` (${username})` : ''}\n`));
  });

// GitHub status
github
  .command('status')
  .description('Show GitHub authentication status')
  .action(async () => {
    const token = config.get('github.token');
    const username = config.get('github.username');

    if (!token) {
      console.log(chalk.yellow('\nâš ï¸  Not authenticated with GitHub'));
      console.log(chalk.cyan('\nTo authenticate:'));
      console.log(chalk.gray('  platform github login\n'));
      return;
    }

    const spinner = ora('Verifying token...').start();
    const result = await verifyGitHubToken(token);

    if (result.success) {
      spinner.succeed(chalk.green('Authenticated with GitHub\n'));
      console.log(chalk.cyan('User:     ') + chalk.white(result.user.login));
      console.log(chalk.cyan('Email:    ') + chalk.white(result.user.email || 'Not public'));
      console.log(chalk.cyan('Profile:  ') + chalk.white(result.user.html_url));
      console.log(chalk.cyan('Config:   ') + chalk.gray(config.path));
      console.log();
    } else {
      spinner.fail(chalk.red('Token is invalid or expired'));
      console.log(chalk.yellow('\nYour token may have expired.'));
      console.log(chalk.cyan('To fix:'));
      console.log('  1. Create new token: https://github.com/settings/tokens');
      console.log('  2. Run: platform github login\n');
    }
  });

// GitHub open
github
  .command('open')
  .description('Open repository in browser')
  .action(async () => {
    try {
      const git = simpleGit(process.cwd());
      const isRepo = await git.checkIsRepo();

      if (!isRepo) {
        console.error(chalk.red('\nNot a git repository\n'));
        process.exit(1);
      }

      const remotes = await git.getRemotes(true);
      const origin = remotes.find(r => r.name === 'origin');

      if (!origin) {
        console.error(chalk.red('\nNo remote origin found\n'));
        process.exit(1);
      }

      // Extract GitHub URL
      let url = origin.refs.fetch;
      if (url.startsWith('git@github.com:')) {
        url = url.replace('git@github.com:', 'https://github.com/');
      }
      url = url.replace(/\.git$/, '');

      console.log(chalk.cyan(`\nOpening: ${url}\n`));
      await open(url);
    } catch (error) {
      console.error(chalk.red(`\nError: ${error.message}\n`));
      process.exit(1);
    }
  });

// GitHub create (for existing service)
github
  .command('create')
  .description('Create GitHub repository for current directory')
  .option('-p, --private', 'Make repository private')
  .option('-d, --description <desc>', 'Repository description')
  .action(async (cmdOptions) => {
    try {
      const serviceName = path.basename(process.cwd());
      const git = simpleGit(process.cwd());
      const isRepo = await git.checkIsRepo();

      if (!isRepo) {
        console.log(chalk.yellow('\nInitializing git repository...\n'));
        await git.init();
        await git.add('.');
        await git.commit('Initial commit');
      }

      const repo = await createGitHubRepository(serviceName, {
        description: cmdOptions.description,
        visibility: cmdOptions.private ? 'private' : 'public'
      });

      if (repo) {
        const pushSuccess = await pushToGitHub(process.cwd(), repo.clone_url, serviceName);

        if (pushSuccess) {
          console.log(chalk.green.bold('\nâœ… Success!\n'));
          console.log(chalk.cyan('ðŸ”— GitHub: ') + chalk.gray(repo.html_url));
          console.log();
        }
      }
    } catch (error) {
      console.error(chalk.red(`\nError: ${error.message}\n`));
      process.exit(1);
    }
  });

// GitHub push
github
  .command('push')
  .description('Push current changes to GitHub')
  .action(async () => {
    try {
      const git = simpleGit(process.cwd());
      const isRepo = await git.checkIsRepo();

      if (!isRepo) {
        console.error(chalk.red('\nNot a git repository\n'));
        process.exit(1);
      }

      const spinner = ora('Pushing to GitHub...').start();

      await git.add('.');
      await git.commit('Update from platform-toolkit');
      await git.push('origin', 'main');

      spinner.succeed(chalk.green('Pushed to GitHub\n'));
    } catch (error) {
      console.error(chalk.red(`\nError: ${error.message}\n`));
      process.exit(1);
    }
  });

program.parse(process.argv);

// Show help if no arguments
if (!process.argv.slice(2).length) {
  program.outputHelp();
}
